import java.util.*;

public class Collection {
    public static void main(String[] args) {


    /*
    В Java існує кілька основних інтерфейсів колекцій, які надають різні способи організації
    та маніпулювання даними.
    Основними колекціями в Java є List, Set і Map. Наведу приклади кожного з них з деякими
    доступними методами та поясненнями.

List: List є упорядкованою колекцією, що дозволяє дублювання елементів.
Деякі імплементації List включають ArrayList, LinkedList та Vector.

Приклад:
     */
        List<String> list = new ArrayList<>();

        // Додавання елементів
        list.add("Елемент 1");
        list.add("Елемент 2");
        list.add("Елемент 3");

        // Отримання розміру списку
        int size = list.size(); // Результат: 3

        // Отримання елемента за індексом
        String element = list.get(0); // Результат: "Елемент 1"

        // Видалення елемента
        list.remove(1); // Видалить другий елемент

        // Перевірка наявності елемента
        boolean contains = list.contains("Елемент 3"); // Результат: true

////////////////////////////////////////////////////////////////////////////////////
    /*
    Set: Set - це колекція, яка не дозволяє дублювання елементів.
    Деякі імплементації Set включають HashSet, TreeSet i LinkedHashSet.

    Приклад:
     */
        Set<String> set = new HashSet<>();

        // Додавання елементів
        set.add("Елемент 1");
        set.add("Елемент 2");
        set.add("Елемент 3");

        // Отримання розміру множини
        int sizeSet = set.size(); // Результат: 3

        // Перебір всіх елементів
        for (String elementSet : set) {
            System.out.println(elementSet);
        }

        // Видалення елемента
        set.remove("Елемент 2");

        // Перевірка наявності елемента
        boolean containsElementThree = set.contains("Елемент 3"); // Результат: true

        //////////////////////////////////////////////////////////////////////////////////////

        /*
        Колекція Map в Java використовується для зберігання пар ключ-значення, де кожен ключ унікальний.
         Вона представляє асоціативний масив, де значення можна отримувати за допомогою ключа.
         Map не дозволяє дублювання ключів, але дозволяє значенням бути дубльованими.
         Деякі методи, доступні в Map, включають додавання, видалення та отримання елементів за ключем.
         Реалізації интерфейса Map включають HashMap, TreeMap, LinkedHashMap і Hashtable.
          Приклад:
         */
        // Створення об'єкту Map
        Map<String, Integer> map = new HashMap<>();

        // Додавання пар ключ-значення
        map.put("Один", 1);
        map.put("Два", 2);
        map.put("Три", 3);

        // Отримання значення за ключем
        int value = map.get("Два"); // Результат: 2
        System.out.println(value);

        // Перевірка наявності ключа
        boolean containsKey = map.containsKey("Три"); // Результат: true

        // Перевірка наявності значення
        boolean containsValue = map.containsValue(1); // Результат: true

        // Отримання кількості пар ключ-значення
        int sizeMap = map.size(); // Результат: 3

        // Перебір всіх пар ключ-значення
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            String key = entry.getKey();
            int val = entry.getValue();
            System.out.println("Ключ: " + key + ", Значення: " + val);
        }

        // Видалення елемента за ключем
        map.remove("Один");

        /*У цьому прикладі ми створили об'єкт Map з ключами типу String і значеннями типу Integer.
        Додали кілька пар ключ-значення за допомогою методу put(). Щоб отримати значення за ключем,
        використовується метод get(). Методи containsKey() і containsValue() дозволяють перевірити
        наявність ключа або значення у Map. Метод size() повертає кількість пар ключ-значення у Map.
        Метод entrySet() повертає набір об'єктів Map.Entry, які можна перебирати для отримання ключа і значення кожної
         */

        //////////////////////////////////////////////////////////////////////////////////////////////
        /*
        Колекції "стек" (stack) і "черга" (queue) є спеціалізованими типами колекцій в Java,
        які надають різні методи для управління даними згідно зі структурою
        "останній прийшов — перший пішов" (LIFO) для стеку і "перший прийшов — перший пішов" (FIFO)
        для черги.

Стек (Stack): Стек є колекцією, де останній доданий елемент є першим,
який буде вилучено (LIFO - Last-In, First-Out). Стек часто використовується для виконання операцій
у зворотному порядку або для зберігання тимчасових даних.

 приклад:
         */
        // Створення об'єкту Stack
        Stack<String> stack = new Stack<>();

        // Додавання елементів у стек
        stack.push("Елемент 1");
        stack.push("Елемент 2");
        stack.push("Елемент 3");

        // Перевірка порожнього стеку
        boolean isEmpty = stack.isEmpty(); // Результат: false

        // Отримання верхнього елемента стеку (без видалення)
        String topElement = stack.peek(); // Результат: "Елемент 3"

        // Видалення верхнього елемента стеку
        String poppedElement = stack.pop(); // Результат: "Елемент 3"

        // Розмір стеку
        int sizeStack = stack.size(); // Результат: 2
        /*У цьому прикладі ми створили об'єкт Stack, додали елементи у стек за допомогою методу push().
        Метод isEmpty() перевіряє, чи є стек порожнім. Метод peek() повертає верхній елемент стеку
        без видалення. Метод pop() видаляє та повертає верхній елемент стеку. Метод size() повертає розмір стеку.
         */

        ///////////////////////////////////////////////////////////////////////////////////////////

        /*Черга (Queue) є колекцією в Java, де елементи додаються з одного кінця і вилучаються з
        іншого кінця. Елемент, який перший був доданий в чергу, буде першим, що буде вилучено
        (FIFO - First-In, First-Out). Черга використовується для управління об'єктами у
        впорядкованому порядку, наприклад, обробка повідомлень або завдань.
         приклад використання черги:
         */
        // Створення об'єкту Queue
        Queue<String> queue = new LinkedList<>();

        // Додавання елементів у чергу
        queue.offer("Елемент 1");
        queue.offer("Елемент 2");
        queue.offer("Елемент 3");

        // Перевірка порожньої черги
        boolean isEmptyQueue = queue.isEmpty(); // Результат: false

        // Отримання першого елемента черги (без видалення)
        String firstElement = queue.peek(); // Результат: "Елемент 1"

        // Видалення та отримання першого елемента черги
        String removedElement = queue.poll(); // Результат: "Елемент 1"

        // Розмір черги
        int sizeQueue = queue.size(); // Результат: 2
        /*У цьому прикладі ми створили об'єкт Queue за допомогою реалізації LinkedList.
        Додано елементи до черги за допомогою методу offer(). Метод isEmpty() перевіряє, чи є
        черга порожньою. Метод peek() повертає перший елемент черги без видалення.
        Метод poll() видаляє та повертає перший елемент черги. Метод size() повертає розмір черги.

        Потрібно звернути увагу, що для роботи з більш спеціалізованою функціональністю черги,
        такою як блокування потоку, перевірка наявності елементів або обхід елементів,
        можуть використовуватись інші реалізації, наприклад, ArrayBlockingQueue або PriorityQueue.
         */




        /* є колекції:
        List (ArrayList, linkedList, Vector)
        Set (HashSet, TreeSet, LinkedHashSet)
        Queue
        Stack
        Map (HashMap, LinkedHashMap, TreeMap, HashTable)


         */

        /*перед тим як обирати між лістом звертаємо увагу на функції get, add, remove
        в ерейлісті якщо додаємо чи видаляємо елемет то все ссувається, якщо і нам мільйон користувачів то мільйон з них
        переміститься на відміну від лінкед лісті, там кожне значення знає попереднє значення, тому при доданні
        коли ми додаємо елемент то в останньому елементі є силка некст на новий елемент, тобто значення не перебираються
        мільйон раз, ми просто міняємо силку, а в ерейлісті зміщається все тому додання та видалення в середині ерейліста займає
        більше часу
        1. вкожного з лістів є методи гет, ед, рімув,
        в ерейлісті гет по індексу працює швидко як і в масиві
        якщо ми хочемо щось додати в середину чи виділити то варто використовувати лінкедліст
якщо я частіше додаю елементи то викор ерейліст, якщо видаляти чи отримувати то краще викор лінкедліст
         */

 /*
                       ArrayList        LinkedList
        add(begin)         O(n)             O(1)
        add(middle)        O(n)             O(n)
        add(end)           O(n)             O(1)
        add    worst case  O(2n)

        get(begin)         O(1)             O(1)
        get(middle)        O(1)             O(n)
        get(end)           O(1)             O(1)

        remove(begin)         O(n)             O(1)
        remove(middle)        O(n)             O(n)
        remove(end)           O(1)             O(1)
         */

/*List: List представляет упорядоченную коллекцию элементов, где каждый элемент имеет свой индекс. Дублирующиеся элементы разрешены. Некоторые из основных реализаций интерфейса List включают ArrayList, LinkedList и Vector.

Set: Set представляет коллекцию уникальных элементов, где каждый элемент может быть добавлен только один раз. Реализации интерфейса Set включают HashSet, TreeSet и LinkedHashSet.

Queue: Queue представляет коллекцию элементов, где элементы добавляются в конец и извлекаются из начала. Некоторые из основных реализаций интерфейса Queue включают LinkedList, PriorityQueue и ArrayDeque.

Map: Map представляет отображение пар ключ-значение. Каждый ключ должен быть уникальным, но разные ключи могут соответствовать одному значению. Реализации интерфейса Map включают HashMap, TreeMap, LinkedHashMap и Hashtable.

Deque: Deque представляет двустороннюю очередь, где элементы могут быть добавлены или извлечены с обоих концов. Реализации интерфейса Deque включают ArrayDeque и LinkedList.

Stack: Stack представляет стек данных, где элементы добавляются и удаляются только с одного конца. Реализации стека в Java включают класс Stack и ArrayDeque.

Collections: Класс Collections предоставляет утилитарные методы для манипуляции с коллекциями, такие как сортировка, поиск максимального/минимального элемента и другие операции.

Кроме того, в Java 8 и выше были добавлены функциональные интерфейсы и коллекции, такие как Stream и Optional, которые облегчают манипуляции и операции со списками данных.

Вышеупомянутые коллекции представляют лишь некоторые из основных коллекций, доступных в Java. Все они имеют свои уникальные характеристики и применяются в разных ситуациях в зависимости от требований вашей программы.
////////////////////////////////////////////////////
    ліст це масив з гибким розміром
сет це масив з гибким розміром, але він гарантує що у нас зберігатимуться лише унікальні значення
мап - це структура данних з ключем значення, ключ та значення будь якого типу
 зручно використовувати коли нам не потрібно пробігати по всім циклам,
по всім елементам масиву чи ліста чи сета, ми хочемо відразу собі заповнити що все що стосується до якогось користувача
до прикладу до користувача оин відноситиметься ліст, до іншого також буде ліст, в кожного свій ліст
/////////////////////////////////////////////////////////////
/*ArrayList: ArrayList основан на массиве, который автоматически масштабируется по мере добавления или удаления элементов.
    Он предоставляет быстрый доступ к элементам по индексу, что делает его эффективным для операций чтения и обращения к элементам по индексу.
    Однако, вставка и удаление элементов в середине списка может быть медленной, так как требуется сдвигать элементы в массиве.
    LinkedList: LinkedList представляет двусвязный список, где каждый элемент содержит ссылку на предыдущий и следующий элементы.
    Он обеспечивает эффективные операции вставки и удаления элементов в середине списка. Однако, доступ к элементам по индексу может быть медленным,
    так как требуется проходить по списку от начала или конца до нужного индекса.
 */
        /*
• HashSet і HashMap є двома різними реалізаціями інтерфейсу Set і Map в Java.

HashSet:

HashSet є реалізацією інтерфейсу Set.
Використовує хеш-таблицю для зберігання унікальних елементів без дублікатів.
Не зберігає порядок додавання елементів.
Дозволяє швидо виконувати операції перевірки наявності елементу та додавання/видалення елементів за константний час (O(1)).

HashMap:

HashMap є реалізацією інтерфейсу Map.
Використовує хеш-таблицю для зберігання пар ключ-значення.
Дозволяє швидкий доступ до значень за ключем.
Не зберігає порядок додавання пар ключ-значення.
Дозволяє швидко виконувати операції додавання, видалення та отримання значень за ключем в середньому за константний час (O(1)),
але залежно від розміру хеш-таблиці можуть виникати колізії та погіршитися часові характеристики (в середньому O(1), в найгіршому випадку O(n)).

Використовання HashSet і HashMap залежить від конкретної задачі. HashSet зручно використовувати, коли потрібно зберегти унікальні елементи
 без дублікатів. HashMap добре підходить для збереження пар ключ-значення та швидкого доступу до значень за ключем.

Зауважте, що якщо важливим є порядок додавання елементів, можна розглянути використання LinkedHashSet та LinkedHashMap, які зберігають порядок додавання елементів.

Операция	        HashSet	        HashMap
Вставка (insert)	    O(1)	    O(1)
Удаление (delete)	    O(1)	    O(1)
Поиск (lookup)	O(1) в среднем случае, O(n) в худшем случае;	O(1) в среднем случае, O(n) в худшем случае
Итерация (iteration)	O(n)	    O(n)

Вставка (insert): Вставка элемента в HashSet и HashMap обычно выполняется за постоянное время O(1). Это связано с
хэшированием ключа элемента и эффективной обработкой коллизий.

Удаление (delete): Удаление элемента из HashSet и HashMap также обычно выполняется за постоянное время O(1).
Оно основано на хэшировании ключа и удалении элемента по его хэшу.

Поиск (lookup): В HashSet и HashMap поиск элемента выполняется за постоянное время O(1) в среднем случае.
Однако, в худшем случае, когда происходят коллизии хэшей и требуется линейное сканирование, время выполнения
может быть O(n), где n - количество элементов в хэш-таблице или хэш-множестве.

Итерация (iteration): Итерация (перебор) элементов в HashSet и HashMap требует прохода через все элементы.
Поэтому сложность выполнения итерации в обоих случаях составляет O(n), где n - количество элементов в коллекции.
         */

        /*Set і Map, що використовує хеш-таблицю для зберігання пар ключ-значення. Він подібний до HashMap, але він є синхронізованим (тобто його методи є потокобезпечними) і має деякі відмінності у своєму використанні та поведінці. Хоча Hashtable все ще підтримується в Java, рекомендується використовувати HashMap або ConcurrentHashMap, якщо потрібна потокобезпека.

Основні відмінності між HashSet, TreeSet та LinkedHashSet:

HashSet не гарантує порядок елементів і не допускає наявності дублікатів елементів. Вставка, видалення та пошук елементів в HashSet виконуються швидко в середньому за час O(1).
TreeSet автоматично сортує елементи в порядку зростання. Вставка, видалення та пошук елементів в TreeSet виконуються швидко в середньому за час O(log n).
LinkedHashSet зберігає порядок вставки елементів і також не допускає наявності дублікатів. Вставка, видалення та пошук елементів в LinkedHashSet виконуються швидко в середньому за час O(1).
Основні відмінності між HashMap, TreeMap, LinkedHashMap та Hashtable:

HashMap не гарантує порядок елементів і дозволяє наявність дублікатів ключів (але не значень). Вставка, видалення та пошук елементів в HashMap виконуються швидко в середньому за час O(1).
TreeMap автоматично сортує елементи за ключем в порядку зростання. Вставка, видалення та пошук елементів в TreeMap виконуються швидко в середньому за час O(log n).
LinkedHashMap зберігає порядок вставки елементів або порядок доступу до елементів (залежно від використовуваної опції accessOrder). Вставка, видалення та пошук елементів в LinkedHashMap виконуються швидко в середньому за час O(1).
Hashtable є синхронізованим

Крім вищезазначених відмінностей, також є кілька інших особливостей і використання для кожного з цих типів колекцій:

HashSet:

Використовується, коли потрібно швидко перевірити, чи міститься елемент в колекції.
Не допускає наявності дублікатів елементів.
Не зберігає порядок вставки елементів.
Використовує методи hashCode() та equals() для визначення унікальності елементів.
TreeSet:

Використовується, коли потрібно мати сортовану колекцію за значеннями ключів.
Автоматично сортує елементи в порядку зростання (або відповідно до заданого компаратора).
Має більш високі витрати пам'яті і часу на операції порівняння та сортування.
LinkedHashSet:

Зберігає порядок вставки елементів.
Використовується, коли потрібно мати колекцію збереженою в порядку вставки, але також потрібна швидка перевірка наявності елемента.
HashMap:

Використовується для зберігання пар ключ-значення.
Не гарантує порядок елементів.
Дозволяє швидку вставку, видалення та пошук елементів за ключем.
TreeMap:

Використовується, коли потрібно мати сортовану колекцію за ключами.
Автоматично сортує елементи за ключем в порядку зростання (або відповідно до заданого компаратора).
LinkedHashMap:

Зберігає порядок вставки елементів або порядок доступу до елементів.
Використовується, коли потрібно зберігати порядок вставки, але також мати швидку перевірку наявності елемента.
Hashtable:

Використовується, коли потрібна потокобезпека.
Більш витратна з точки зору пам'яті та швидкості порівняно з HashMap.
Кожна реалізація має свої особливості і використання:

LinkedHashSet:

Зберігає порядок вставки елементів, а також підтримує унікальність елементів.
Швидка операція пошуку, вставки та видалення елементів.
Використовується, коли потрібно зберігати порядок вставки елементів, але також важлива швидка перевірка наявності елемента.
HashMap:

Не гарантує порядок елементів за ключем.
Використовується для зберігання пар ключ-значення.
Швидка операція пошуку, вставки та видалення елементів за ключем.
Не допускає дублікатів ключів, але дозволяє наявність дублікатів значень.
TreeMap:

Автоматично сортує елементи за ключем.
Використовується, коли потрібно мати сортовану колекцію за ключами.
Швидка операція пошуку, вставки та видалення елементів за ключем.
Більш витратна з точки зору пам'яті та швидкості порівняно з HashMap.
LinkedHashMap:

Зберігає порядок вставки елементів або порядок доступу до елементів.
Використовується, коли потрібно зберігати порядок вставки елементів або порядок доступу до них.
Швидка операція пошуку, вставки та видалення елементів.
Займає більше місця в пам'яті порівняно з HashMap, оскільки додатково зберігає связаний список для підтримки порядку вставки або доступу.
Hashtable:

Є синхронізованою версією HashMap і забезпечує потокобезпеку.
Використовується, коли потрібна потокобезпека.
Має високі витрати пам'яті та часу порівняно з HashMap і рекомендується використовувати ConcurrentHashMap замість нього.
         */
    }
}