import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Scanner;

    public class Exceptions {
        public static void main(String[] args) {
            //try {
            //    // Код, що може викликати виняток
            //} catch (Exception ex) {
            //    // Обробка винятку
            //} finally {
            //    // Код, що виконується завжди, незалежно від винятку
            //}

        /*
        Винятки (exceptions) є механізмом в мові програмування Java для обробки помилок або непередбачених ситуацій,
        які виникають під час виконання програми. Винятки дозволяють контролювати та відновлювати виконання програми в умовах виникнення помилок.

Основні аспекти винятків, які варто знати, включають:

Виняткова ситуація (Exception): Це непередбачена або помилкова ситуація, яка виникає під час виконання програми. Винятка відображається як об'єкт в Java.

Класи винятків (Exception Classes): В Java існує багато вбудованих класів винятків, які представляють різні типи помилок. Наприклад,
NullPointerException, FileNotFoundException, ArrayIndexOutOfBoundsException і т.д. Крім того, ви також можете створювати свої власні класи винятків.

Блоки try-catch-finally: Ви можете використовувати блоки try, catch та finally для обробки винятків. Блок try містить код, в якому
може виникнути виняток. Блок catch використовується для перехоплення та обробки винятка, а блок finally виконується незалежно від того,
чи сталася виняткова ситуація.

Керування винятками: Ви можете керувати винятками, використовуючи розповсюдження винятків (throwing) за допомогою throw, або обробляти
винятки за допомогою блоку try-catch. Можна також використовувати блок finally для забезпечення виконання певних дій після обробки винятків.

Перехоплення та обробка винятків: Коли виняток виникає в блоку try, виконання коду в цьому блоку припиняється, і система шукає
відповідний блок catch.

Багаторівнева обробка винятків: Ви можете використовувати багаторівневу обробку винятків, коли ви хочете обробити виняток на різних рівнях
 виклику методів. Для цього можна використовувати кілька блоків try-catch, один вкладений у інший.

try {
    // Код, що може викликати виняток
    try {
        // Код, що може викликати виняток
    } catch (Exception ex) {
        // Обробка винятка на внутрішньому рівні
    }
} catch (Exception ex) {
    // Обробка винятка на зовнішньому рівні
}
Викидання винятків: Ви можете викликати виняток за допомогою ключового слова throw. Це дозволяє вам створювати та викидати
власні винятки в потрібних випадках.

public void doSomething() throws CustomException {
    // Код, що викликає виняток
    if (someCondition) {
        throw new CustomException("Повідомлення про помилку");
    }
}
Обробка неочікуваних винятків: Якщо ви не бажаєте або не можете обробляти певний виняток на місці, ви можете використовувати
throws або throw для перебросу винятка вище по стеку викликів.

public void doSomething() throws CustomException {
    // Код, що викликає виняток
    if (someCondition) {
        throw new CustomException("Повідомлення про помилку");
    }
    // Код, який не може обробити виняток і перебрасує його
    throw new RuntimeException("Неочікуваний виняток");
}
Знання про винятки важливо для побудови стабільних і надійних програм, оскільки вони дозволяють вам контролювати та обробляти помилки,
 які можуть виникати під час виконання вашої програми. Обробка винятків допомагає забезпечити відновлення, логування та повідомлення про помилки

Перехоплення багатьох типів винятків: У блоку catch можна перехоплювати не тільки один тип винятку, але й декілька типів. Це дозволяє вам виконати різні дії в залежності від типу винятку.
java
Copy code
try {
    // Код, що може викликати виняток
} catch (ExceptionType1 ex1) {
    // Обробка винятку типу ExceptionType1
} catch (ExceptionType2 ex2) {
    // Обробка винятку типу ExceptionType2
} catch (Exception ex) {
    // Обробка інших винятків
}
Винятки в ієрархії: Класи винятків у Java утворюють ієрархію, де батьківські класи винятків є загальними для дочірніх класів.
Це означає, що ви можете перехоплювати або викидати виняток більш широкого класу, щоб включити в себе підтипи.

try {
    // Код, що може викликати виняток
} catch (IOException ex) {
    // Обробка винятків, пов'язаних з вводом-виводом
} catch (Exception ex) {
    // Обробка інших винятків
}
Користувацькі винятки: Ви можете створювати свої власні класи винятків, наслідуючись від класу Exception або його підкласів. Це корисно, коли ви хочете викидати винятки, що відповідають певним ситуаціям у вашій програмі.

public class CustomException extends Exception {
    // Конструктори, методи та інші деталі
}

// Викидання користувацького винятка
throw new CustomException("Повідомлення про помилку");
Уникання використання винятків для потоку управління: Винятки мають високу вартість у виконанні, тому рекомендується не використовувати
їх для потоку управління програмою.


Перевірка перед виникненням винятків (Exception Checking): Кращою практикою є уникання перевірки на винятки перед їх виникненням.
Замість цього, рекомендується використовувати механізми перевірки перед виконанням винятків, такі як перевірка значень або використання
умовних конструкцій, щоб уникнути ситуацій, коли виняток виникає через некоректні дані чи стан програми.

Логування винятків: Для відлагодження та аналізу помилок важливо забезпечити логування винятків. Це допомагає відстежувати та аналізувати
винятки, які виникають у програмі, і дозволяє швидко знайти та виправити проблеми.

Виключення від RuntimeException: Винятки, що наслідуються від класу RuntimeException, відносяться до виключень, які не потрібно обов'язково
обробляти або вказувати в підписі методу за допомогою throws. Ці винятки є неконтрольованими, тобто вони можуть бути викинуті без явного оброблення.

Коректне закриття ресурсів: Якщо ваша програма використовує ресурси, такі як файли, з'єднання з базою даних або сокети, важливо забезпечити
їх коректне закриття, навіть у випадку виникнення винятків. Для цього можна використовувати блок finally або конструкцію try-with-resources,
яка автоматично закриє ресурси при виході з блоку try.


Винятки слід записувати у коді в таких випадках:

Коли виконання певної операції може призвести до виникнення непередбачуваних ситуацій або помилок. Наприклад, робота з файлами, мережеві
операції, доступ до бази даних, введення/виведення даних тощо. У цих випадках винятки допомагають передати інформацію про помилку або
некоректний стан програми.

Коли необхідно повідомити про помилку або некоректний вхідний параметр методу. Наприклад, якщо метод очікує деякі обмеження на значення
параметрів і викликач передає некоректні дані, то можна викинути виняток для попередження про некоректну вхідну інформацію.

Коли виникає ситуація, коли подальше виконання коду стає неможливим або небезпечним. Наприклад, помилки в механізмах вводу-виводу, ділення
на нуль, вихід за межі масиву тощо. Винятки дозволяють зупинити виконання коду та забезпечити його коректну обробку.

У деяких випадках можна використовувати вже наявні винятки зі стандартної бібліотеки Java, наприклад, IOException для роботи з файлами
або SQLException для операцій з базою даних. В інших випадках можна створювати власні винятки, успадковані від класу Exception або його
підкласів, щоб передати специфічну інформацію про помилку.

Важливо розуміти, що не всі помилки повинні бути винятками. Деякі помилки можна передавати через повернення спеціальних значень або
використання флагів помилок. Використовуйте винятки лише тоді, коли вони дійсно вказують на непередбачувані або критичні помилки


Наступним кроком після визначення, в яких випадках слід записувати винятки, є реалізація обробки винятків у вашому коді. Основні підходи до
обробки винятків включають:

Використання блоку try-catch: Ви можете оточити частину коду, яка може викликати виняток, блоком try. Ви можете вказати один або декілька
блоків catch, кожен з яких обробляє певний тип винятка і виконує певні дії для обробки помилки.

try {
    // Код, який може викликати виняток
} catch (ExceptionType1 ex1) {
    // Обробка винятка типу ExceptionType1
} catch (ExceptionType2 ex2) {
    // Обробка винятка типу ExceptionType2
} finally {
    // Код, який виконується завжди, незалежно від того, чи виник виняток
}
Викидання винятків: Ви можете використовувати оператор throw для викидання власних винятків у випадку виявлення помилки. Ви можете створювати
власні класи винятків, успадковані від класу Exception, і передавати додаткову інформацію про помилку.

if (someCondition) {
    throw new CustomException("Повідомлення про помилку");
}
Обробка винятків на вищому рівні: Якщо ви не плануєте обробляти винятки локально, ви можете передати їх на вищий рівень вашої програми.
Це може включати використання оператора throws в оголошенні методу для передачі винятків викликачу методу або викидання винятків на рівень
вище в ієрархії викликів методів.

public void someMethod() throws CustomException {
    // Код, який може викликати виняток
}
         */
            //checked (compile time exception) = исключительные случаи в работе программе
            //unchecked (runtime exception) = ошибка в работе программы, ее не надо обрабатывать, ее надо устранять

        /*
        Найголовніше про checked (compile time exception) та unchecked (runtime exception) винятки наступне:

Checked винятки:

Це винятки, які перевіряються компілятором під час компіляції коду.
Вони відносяться до класу Exception або його підкласів, за винятком RuntimeException та його підкласів.
Компілятор вимагає, щоб ви обробили (за допомогою блоку try-catch або оператора throws) ці винятки, інакше код не буде компілюватися.
Приклади checked винятків: IOException, SQLException, ClassNotFoundException.
Checked винятки зазвичай виникають у випадку зовнішніх ресурсів або операцій, які можуть викликати помилки, як-от робота з файлами, мережевими операціями або базами даних.
Unchecked винятки:

Це винятки, які не перевіряються компілятором під час компіляції коду.
Вони відносяться до класу RuntimeException або його підкласів.
Код, що містить unchecked винятки, може бути компільований без обов'язкового оброблення цих винятків.
Ці винятки виникають під час виконання програми в результаті помилок або неправильного використання методів.
Приклади unchecked винятків: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException.
Unchecked винятки зазвичай виникають у випадку помилок програмування, некоректних вхідних даних або непередбачуваних ситуацій.

Загальна рекомендація полягає в тому, щоб використовувати checked винятки для ситуацій, коли помилка може бути передбачена та оброблена в коді,
і використовувати unchecked винятки для ситуацій, коли помилка вказує на серйозну помилку програми або непередбачувану ситуацію,
і вона не може бути ефективно вирішена в коді.
         */

//        File file2 = new File("test");
//        try {
//            Scanner scanner2 = new Scanner(file2);
//        } catch (FileNotFoundException ex) {
//            ex.printStackTrace(); //краще не використовувати цей метод по умолчанію, а оброблювати помилки щоб користувачу було не страшно коли він з цим стикнеться
//        }
//
//        File outputContacts = new File("test");
//        try {
//            Scanner console = new Scanner(outputContacts);
//        } catch (FileNotFoundException e) {
//            throw new RuntimeException();
//        }
//
//        File input = new File("test");
//        try {
//            Scanner scanner = new Scanner(input);
//        } catch (FileNotFoundException e) {
//            System.out.println("file in not found");
//        }
//
//        File inputOutput = new File("test");
//        try {
//            Scanner scanner7 = new Scanner(input);
//        } catch (FileNotFoundException e) {
//            System.out.println("file in not found");
//        }

        }
//
//        public static void getFile() {
//            System.out.println("вичитка з фалу не вдалася");
//        }
//
//    File file = new File("test");
//    Scanner scanner = new Scanner(file);
//
//    public Exceptions() throws FileNotFoundException {
//    }


        public class ertyuio {
            public static void main(String[] args)
//            throws FileNotFoundException
            {
//        File file = new File("test");
//        try {
//            Scanner scanner = new Scanner(file);
//            System.out.println("after scanner");
//        } catch (FileNotFoundException e) {
//            System.out.println("file not found");
//        }
//        System.out.println("after try catch");

//        System.out.println(getError());

//        1. File file = new File("test");
//        Scanner scanner;
//        try {
//            scanner = new Scanner(file);
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }
//       try {
//           getError();
//       } catch (FileNotFoundException e){
//        throw new RuntimeException();
//    }

                Scanner console = new Scanner(System.in);

                while(true) {
                    int x = Integer.parseInt(console.nextLine());
                    if (x != 4) {
                        try {
                            throw new IOException();
                        } catch (IOException e) {
                            System.out.println("please re-enter the data");
                        }
                    }
                }
            }
            public static void getError() throws FileNotFoundException {
                File file = new File("test1");
                Scanner scanner = new Scanner(file);
            }
            public  class ScannerException extends ertyuio { //створила інший клас щоб створити свій іксепшн

            }

        }



    }


